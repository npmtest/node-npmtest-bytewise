{"/home/travis/build/npmtest/node-npmtest-bytewise/test.js":"/* istanbul instrument in package npmtest_bytewise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bytewise/lib.npmtest_bytewise.js":"/* istanbul instrument in package npmtest_bytewise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bytewise = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bytewise = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bytewise/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bytewise && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bytewise */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bytewise\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bytewise.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bytewise.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bytewise.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bytewise.__dirname + '/lib.npmtest_bytewise.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise/index.js":"// TODO: initialize and export a standard bytewise encoding, add hex and binary\nmodule.exports = require('./encoding/')\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise/encoding/index.js":"// TODO: standard bytewise encoding constructor\n// TODO: enhance binary encoding with optional hex helpers\nmodule.exports = require('./binary')","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise/encoding/binary.js":"// require typewise first to extend with core typewise functionality\nrequire('typewise')\n\n// TODO: bytewise-binary encoding -- no hex parsing or toString hackery\nmodule.exports = require('bytewise-core')\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise-core/index.js":"var assert = require('./util').assert\nvar base = require('./base')\nvar codecs = require('./codecs')\n\nvar bytewise = exports\n\n//\n// expose type information\n//\nvar sorts = bytewise.sorts = base.sorts\nbytewise.bound = base.bound\nbytewise.compare = base.compare\nbytewise.equal = base.equal\n\n//\n// generate a buffer with type's byte prefix from source value\n//\nfunction serialize(type, source, options) {\n  var codec = type.codec\n  if (!codec)\n    return postEncode(new Buffer([ type.byte ]), options)\n\n  var buffer = codec.encode(source, bytewise)\n\n  if (options && options.nested && codec.escape)\n    buffer = codec.escape(buffer)\n\n  var hint = typeof codec.length === 'number' ? (codec.length + 1) : void 0 \n  var buffers = [ new Buffer([ type.byte ]), buffer ]\n  return postEncode(Buffer.concat(buffers, hint), options)\n}\n\n//\n// core encode logic\n//\nbytewise.encode = function(source, options) {\n\n  // check for invalid/incomparable values\n  assert(!base.invalid(source), 'Invalid value')\n\n  // encode bound types (ranges)\n  var boundary = base.bound.getBoundary(source)\n  if (boundary)\n    return boundary.encode(source, bytewise)\n\n  // encode standard value-typed sorts\n  var order = base.order\n  var sort\n  for (var i = 0, length = order.length; i < length; ++i) {\n    sort = sorts[order[i]]\n\n    if (sort.is(source)) {\n\n      // loop over any subsorts defined on sort\n      // TODO: clean up\n      var subsorts = sort.sorts ||  { '': sort }\n      for (key in subsorts) {\n        var subsort = subsorts[key]\n        if (subsort.is(source)) \n          return serialize(subsort, source, options)\n      }\n\n      // source is an unsupported subsort\n      assert(false, 'Unsupported sort value')\n    }\n  }\n\n  // no type descriptor found\n  assert(false, 'Unknown value')\n}\n\n//\n// core decode logic\n//\nbytewise.decode = function (buffer, options) {\n  // attempt to decode string input using configurable codec\n  if (typeof buffer === 'string') {\n    buffer = bytewise.stringCodec.encode(buffer)\n  }\n\n  assert(!buffer || !buffer.undecodable, 'Encoded value not decodable')\n\n  var byte = buffer[0]\n  var type = bytewise.getType(byte)\n  assert(type, 'Invalid encoding: ' + buffer)\n\n  // if type provides a decoder it is passed the base type system as second arg\n  var codec = type.codec\n  if (codec) {\n    var decoded = codec.decode(buffer.slice(1), bytewise)\n\n    if (options && options.nested && codec.unescape)\n      decoded = codec.unescape(decoded)\n\n    return postDecode(decoded, options)\n  }\n\n  // nullary types without a codec must provide a value for their decoded form\n  assert('value' in type, 'Unsupported encoding: ' + buffer)\n  return postDecode(type.value, options)\n}\n\n//\n// process top level\n//\nfunction postEncode(encoded, options) {\n  if (options === null)\n    return encoded\n\n  return bytewise.postEncode(encoded, options)\n}\n\n//\n// invoked after encoding with encoded buffer instance\n//\nbytewise.postEncode = function (encoded, options) {\n\n  // override buffer toString method to default to hex to help coercion issues\n  // TODO: just return pure buffer, do this toString hackery in bytewise\n  encoded.toString = function (encoding) {\n    if (!encoding)\n      return bytewise.stringCodec.decode(encoded)\n\n    return Buffer.prototype.toString.apply(encoded, arguments)\n  }\n\n  return encoded\n}\n\nfunction postDecode(decoded, options) {\n  if (options === null)\n    return decoded\n\n  return bytewise.postDecode(decoded, options)\n}\n\n//\n// invoked after decoding with decoded value\n//\nbytewise.postDecode = function (decoded, options) {\n  return decoded\n}\n\n\n//\n// registry mapping byte prefixes to type descriptors\n//\nvar PREFIX_REGISTRY\n\nfunction registerType(type) {\n  var byte = type && type.byte\n  if (byte == null)\n    return\n\n  if (byte in PREFIX_REGISTRY)\n    assert.deepEqual(type, PREFIX_REGISTRY[byte], 'Duplicate prefix: ' + byte)\n\n  PREFIX_REGISTRY[type.byte] = type\n}\n\nfunction registerTypes(types) {\n  for (var key in types) {\n    registerType(types[key])\n  }\n}\n\n//\n// look up type descriptor associated with a given byte prefix\n//\nbytewise.getType = function (byte) {\n\n  // construct and memoize byte prefix registry on first run\n  if (!PREFIX_REGISTRY) {\n    PREFIX_REGISTRY = {}\n\n    // register sorts\n    var sort\n    for (var key in sorts) {\n      sort = sorts[key]\n\n      // if sort has subsorts register these instead\n      sort.sorts ? registerTypes(sort.sorts) : registerType(sort)\n    }\n  }\n\n  return PREFIX_REGISTRY[byte]\n}\n\nbytewise.buffer = true\nbytewise.stringCodec = codecs.HEX\nbytewise.type = 'bytewise-core'\n\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise-core/util.js":"var util = exports\n\n//\n// buffer compare\n//\nutil.compare = require('typewise-core/collation').bitwise\n\n//\n// buffer equality\n//\nutil.equal = function (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))\n    return\n\n  if (a === b)\n    return true\n\n  if (typeof a.equals === 'function')\n    return a.equals(b)\n\n  return util.compare(a, b) === 0\n}\n\nvar assert = util.assert = function (test, message) {\n  if (!test)\n    throw new TypeError(message)\n}\n\nvar FLOAT_LENGTH = 8\n\nutil.invertBytes = function (buffer) {\n  var bytes = []\n  for (var i = 0, end = buffer.length; i < end; ++i) {\n    bytes.push(~buffer[i])\n  }\n\n  return new Buffer(bytes)\n}\n\nutil.encodeFloat = function (value) {\n  var buffer = new Buffer(FLOAT_LENGTH)\n  if (value < 0) {\n    //\n    // write negative numbers as negated positive values to invert bytes\n    //\n    buffer.writeDoubleBE(-value.valueOf(), 0)\n    return util.invertBytes(buffer)\n  }\n\n  //\n  // normalize -0 values to 0\n  //\n  buffer.writeDoubleBE(value.valueOf() || 0, 0)\n  return buffer\n}\n\nutil.decodeFloat = function (buffer, base, negative) {\n  assert(buffer.length === FLOAT_LENGTH, 'Invalid float encoding length')\n\n  if (negative)\n    buffer = util.invertBytes(buffer)\n\n  var value = buffer.readDoubleBE(0)\n  return negative ? -value : value\n}\n\n//\n// sigil for controlling the escapement functions (TODO: clean this up)\n//\nvar SKIP_HIGH_BYTES = {}\n\nutil.escapeFlat = function (buffer, options) {\n  //\n  // escape high and low bytes 0x00 and 0xff (and by necessity, 0x01 and 0xfe)\n  //\n  var b, bytes = []\n  for (var i = 0, end = buffer.length; i < end; ++i) {\n    b = buffer[i]\n\n    //\n    // escape low bytes with 0x01 and by adding 1\n    //\n    if (b === 0x01 || b === 0x00)\n      bytes.push(0x01, b + 1)\n\n    //\n    // escape high bytes with 0xfe and by subtracting 1\n    //\n    else if (options !== SKIP_HIGH_BYTES && (b === 0xfe || b === 0xff))\n      bytes.push(0xfe, b - 1)\n\n    //\n    // no escapement needed\n    //\n    else\n      bytes.push(b)\n  }\n\n  return new Buffer(bytes)\n}\n\nutil.unescapeFlat = function (buffer, options) {\n  var b, bytes = []\n  //\n  // don't escape last byte\n  //\n  for (var i = 0, end = buffer.length; i < end; ++i) {\n    b = buffer[i]\n\n    //\n    // if low-byte escape tag use the following byte minus 1\n    //\n    if (b === 0x01)\n      bytes.push(buffer[++i] - 1)\n\n    //\n    // if high-byte escape tag use the following byte plus 1\n    //\n    else if (options !== SKIP_HIGH_BYTES && b === 0xfe)\n      bytes.push(buffer[++i] + 1)\n\n    //\n    // no unescapement needed\n    //\n    else\n      bytes.push(b)\n  }\n  return new Buffer(bytes)\n}\n\nutil.escapeFlatLow = function (buffer) {\n  return util.escapeFlat(buffer, SKIP_HIGH_BYTES)\n}\n\nutil.unescapeFlatLow = function (buffer) {\n  return util.unescapeFlat(buffer, SKIP_HIGH_BYTES)\n}\n\nutil.encodeList = function (source, base) {\n  // TODO: cycle detection\n  var buffers = []\n  var undecodable\n\n  for (var i = 0, end = source.length; i < end; ++i) {\n    var buffer = base.encode(source[i], null)\n\n    //\n    // bypass assertions for undecodable types (i.e. range bounds)\n    //\n    undecodable || (undecodable = buffer.undecodable)\n    if (undecodable) {\n      buffers.push(buffer)\n      continue\n    }\n\n    var sort = base.getType(buffer[0])\n    assert(sort, 'List encoding failure: ' + buffer)\n\n    //\n    // escape sorts if it requires it and add closing byte for element\n    //\n    if (sort.codec && sort.codec.escape)\n      buffers.push(sort.codec.escape(buffer), new Buffer([ 0x00 ]))\n\n    else\n      buffers.push(buffer)\n  }\n\n  //\n  // close the list with an end byte\n  //\n  buffers.push(new Buffer([ 0x00 ]))\n  buffer = Buffer.concat(buffers)\n\n  //\n  // propagate undecoable bit if set\n  //\n  undecodable && (buffer.undecodable = undecodable)\n  return buffer\n}\n\nutil.decodeList = function (buffer, base) {\n  var result = util.parse(buffer, base)\n\n  assert(result[1] === buffer.length, 'Invalid encoding')\n  return result[0]\n}\n\nutil.encodeHash = function (source, base) {\n  //\n  // packs hash into an array, e.g. `[ k1, v1, k2, v2, ... ]`\n  //\n  var list = []\n  Object.keys(source).forEach(function(key) {\n    list.push(key)\n    list.push(source[key])\n  })\n  return util.encodeList(list, base)\n}\n\nutil.decodeHash = function (buffer, base) {\n  var list = util.decodeList(buffer, base)\n  var hash = Object.create(null)\n\n  for (var i = 0, end = list.length; i < end; ++i) {\n    hash[list[i]] = list[++i]\n  }\n\n  return hash\n}\n\n//\n// base parser for nested/recursive sorts\n//\nutil.parse = function (buffer, base, sort) {\n  //\n  // parses and returns the first sort on the buffer and total bytes consumed\n  //\n  var codec = sort && sort.codec\n  var index, end\n\n  //\n  // nullary\n  //\n  if (sort && !codec)\n    return [ base.decode(new Buffer([ sort.byte ]), null), 0 ]\n\n  //\n  // custom parse implementation provided by sort\n  //\n  if (codec && codec.parse)\n    return codec.parse(buffer, base, sort)\n\n  //\n  // fixed length sort, decode fixed bytes\n  //\n  var length = codec && codec.length\n  if (typeof length === 'number')\n    return [ codec.decode(buffer.slice(0, length)), length ]\n\n  //\n  // escaped sort, seek to end byte and unescape\n  //\n  if (codec && codec.unescape) {\n    for (index = 0, end = buffer.length; index < end; ++index) {\n      if (buffer[index] === 0x00)\n        break\n    }\n\n    assert(index < buffer.length, 'No closing byte found for sequence')\n    var unescaped = codec.unescape(buffer.slice(0, index))\n\n    //\n    // add 1 to index to account for closing tag byte\n    //\n    return [ codec.decode(unescaped), index + 1 ]\n  }\n\n  //\n  // recursive sort, resolve each item iteratively\n  //\n  index = 0\n  var list = []\n  var next\n  while ((next = buffer[index]) !== 0x00) {\n    sort = base.getType(next)\n    var result = util.parse(buffer.slice(index + 1), base, sort)\n    list.push(result[0])\n\n    //\n    // offset current index by bytes consumed (plus a byte for the sort tag)\n    //\n    index += result[1] + 1\n    assert(index < buffer.length, 'No closing byte found for nested sequence')\n  }\n\n  //\n  // return parsed list and bytes consumed (plus a byte for the closing tag)\n  //\n  return [ list, index + 1 ]\n}\n\n//\n// helpers for encoding boundary types\n//\nfunction encodeBound(data, base) {\n  var prefix = data.prefix\n  var buffer = prefix ? base.encode(prefix, null) : new Buffer([ data.byte ])\n\n  if (data.upper)\n    buffer = Buffer.concat([ buffer, new Buffer([ 0xff ]) ])\n\n  return util.encodedBound(data, buffer)\n}\n\nutil.encodeBound = function (data, base) {\n  return util.encodedBound(data, encodeBound(data, base))\n}\n\nutil.encodeBaseBound = function (data, base) {\n  return util.encodedBound(data, new Buffer([ data.upper ? 0xff : 0x00 ]))\n}\n\nutil.encodeListBound = function (data, base) {\n  var buffer = encodeBound(data, base)\n\n  if (data.prefix) {\n    //\n    // trim off end byte if a prefix, and do some hackery if an upper bound\n    //\n    var endByte = buffer[buffer.length - 1]\n    buffer = buffer.slice(0, -1)\n    if (data.upper)\n      buffer[buffer.length - 1] = endByte\n  }\n\n  return util.encodedBound(data, buffer)\n}\n\n//\n// add some metadata to generated buffer instance\n//\nutil.encodedBound = function (data, buffer) {\n  buffer.undecodable = true\n  return buffer\n}\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise-core/base.js":"var base = require('typewise-core/base')\nvar codecs = require('./codecs')\nvar util = require('./util')\n\n//\n// extend core sorts defined by typewise with bytewise-specific functionality\n//\n\n// byte represents byte tag prefix in encoded form, enforcing binary total order\n// type tag is 1 byte, which gives us plenty of room to grow\n\n//\n// boundary types\n//\nbase.bound.encode = util.encodeBaseBound\n\n//\n// value types\n//\nvar sorts = base.sorts\n\nsorts.void.byte = 0xf0\n\nsorts.null.byte = 0x10\n\n\nvar BOOLEAN = sorts.boolean\nBOOLEAN.sorts.false.byte = 0x20\nBOOLEAN.sorts.true.byte = 0x21\nBOOLEAN.bound.encode = util.encodeBound\n\n\nvar NUMBER = sorts.number\nNUMBER.sorts.min.byte = 0x40\nNUMBER.sorts.negative.byte = 0x41\nNUMBER.sorts.positive.byte = 0x42\nNUMBER.sorts.max.byte = 0x43\nNUMBER.sorts.negative.codec = codecs.NEGATIVE_FLOAT\nNUMBER.sorts.positive.codec = codecs.POSITIVE_FLOAT\nNUMBER.bound.encode = util.encodeBound\n\n\nvar DATE = sorts.date\nDATE.sorts.negative.byte = 0x51\nDATE.sorts.positive.byte = 0x52\nDATE.sorts.negative.codec = codecs.PRE_EPOCH_DATE\nDATE.sorts.positive.codec = codecs.POST_EPOCH_DATE\nDATE.bound.encode = util.encodeBound\n\n\nvar BINARY = sorts.binary\nBINARY.byte = 0x60\nBINARY.codec = codecs.UINT8\nBINARY.bound.encode = util.encodeBound\n\n\nvar STRING = sorts.string\nSTRING.byte = 0x70\nSTRING.codec = codecs.UTF8\nSTRING.bound.encode = util.encodeBound\n\n\nvar ARRAY = sorts.array\nARRAY.byte = 0xa0\nARRAY.codec = codecs.LIST\nARRAY.bound.encode = util.encodeListBound\n\n\n// var OBJECT = sorts.object\n// OBJECT.byte = 0xb0\n// OBJECT.codec = codecs.HASH\n// OBJECT.bound.encode = util.encodeListBound\n\nmodule.exports = base\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise-core/codecs.js":"var util = require('./util')\n\nvar FLOAT_LENGTH = 8\n\nfunction identity(value) {\n  return value\n}\n\nfunction shortlexEncode(codec) {\n  return function (source, base) {\n    // stupid lazy implementation\n    // TODO: allow length getter to be provided\n    var length = util.encodeFloat(source.length)\n    var body = codec.encode(source, base)\n    return Buffer.concat([ length, body ])\n  }\n}\n\nfunction shortlexDecode(codec) {\n  return function (buffer) {\n    // stupid lazy implementation\n    return codec.decode(this, buffer.slice(FLOAT_LENGTH))\n  }\n}\n\nfunction shortlexParse(codec) {\n  // TODO\n  return function (buffer, base) {\n    throw new Error('NYI')\n  }\n}\n\nfunction shortlex(codec) {\n  return {\n    encode: shortlexEncode(codec),\n    decode: shortlexDecode(codec),\n    parse: shortlexParse(codec)\n  }\n}\n\n//\n// pairs of encode/decode functions\n//\nvar codecs = exports\n\ncodecs.HEX = {\n  encode: function (source) {\n    return new Buffer(source, 'hex')\n  },\n  decode: function (buffer) {\n    return buffer.toString('hex')\n  }\n}\n\ncodecs.UINT8 = {\n  encode: identity,\n  decode: identity,\n  escape: util.escapeFlat,\n  unescape: util.unescapeFlat\n}\n\ncodecs.UINT8_SHORTLEX = shortlex(codecs.UINT8)\n\ncodecs.UTF8 = {\n  encode: function (source) {\n    return new Buffer(source, 'utf8')\n  },\n  decode: function (buffer) {\n    return buffer.toString('utf8')\n  },\n  escape: util.escapeFlatLow,\n  unescape: util.unescapeFlatLow\n}\n\ncodecs.UTF8_SHORTLEX = shortlex(codecs.UTF8)\n\ncodecs.POSITIVE_FLOAT = {\n  length: FLOAT_LENGTH,\n  encode: util.encodeFloat,\n  decode: util.decodeFloat\n}\n\ncodecs.NEGATIVE_FLOAT = {\n  length: FLOAT_LENGTH,\n  encode: util.encodeFloat,\n  decode: function (buffer) {\n    return util.decodeFloat(buffer, null, true)\n  }\n}\n\ncodecs.POST_EPOCH_DATE = {\n  length: FLOAT_LENGTH,\n  encode: util.encodeFloat,\n  decode: function (buffer) {\n    return new Date(util.decodeFloat(buffer))\n  }\n}\n\ncodecs.PRE_EPOCH_DATE = {\n  length: FLOAT_LENGTH,\n  encode: util.encodeFloat,\n  decode: function (buffer) {\n    return new Date(util.decodeFloat(buffer, null, true))\n  }\n}\n\n//\n// base encoding for complex structures\n//\ncodecs.LIST = {\n  encode: util.encodeList,\n  decode: util.decodeList\n}\n\ncodecs.TUPLE = shortlex(codecs.LIST)\n\n//\n// member order is preserved and accounted for in sort (except for number keys)\n//\ncodecs.HASH = {\n  // TODO\n  // encode: util.encodeHash,\n  // decode: util.decodeHash\n}\n\ncodecs.RECORD = shortlex(codecs.HASH)\n","/home/travis/build/npmtest/node-npmtest-bytewise/node_modules/bytewise/encoding/hex.js":"// TODO: encoding class hierarchy\n\nvar core = require('./binary')\n\nexports.encode = function (source) {\n  return core.encode(source).toString('hex')\n}\n\nexports.decode = function (buffer) {\n  return core.decode(buffer.toString('hex'))\n}\n\nexports.buffer = false;\nexports.type = 'bytewise-hex';\n"}